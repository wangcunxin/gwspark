1.常见排序算法及其对应的时间复杂度和空间复杂度
    排序方法/时间复杂度(平均)/时间复杂度(最坏)/时间复杂度(最好)/空间复杂度/稳定性/复杂性
    插入排序/O(n2)/O(n2)/O(n)/O(1)/稳定/简单
    希尔排序/O(nlog2n)/O(n2)/O(n1.3)/O(1)/不稳定/较复杂
    选择排序/O(n2)/O(n2)/O(n2)/O(1)/不稳定/简单
    堆排序/O(nlog2n)/O(nlog2n)/O(nlog2n)/O(1)/不稳定/较复杂
    冒泡排序/O(n2)/O(n2)/O(n)/O(1)/稳定/简单
    快速排序/O(nlog2n)/O(n2)/O(nlog2n)/O(nlog2n)/不稳定/较复杂
    归并排序/O(nlog2n)/O(nlog2n)/O(nlog2n)/O(n)/稳定/较复杂
    基数排序/O(d(n+r))/O(d(n+r))/O(d(n+r))/O(n+r)/稳定/较复杂


2.内排序分类：
    1）插入排序：直接插入排序、二分法插入排序、希尔排序
    2）选择排序：直接选择排序、堆排序
    3）交换排序：冒泡排序、快速排序
    4）归并排序
    5）基数排序

3.说明
3.1快速排序
选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一轮扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分，直到各区间只有一个数。
最好情况：是每轮划分都将待排序列正好分为两部分，那么每部分需要的时间为上一轮的1/2。如果排序n个元素的序列，其递归树深度为[logn]+1即仅需递归logn次，需要总时间为T(n)的话，第一次需要扫描整个序列，做n次比较，然后将序列一分为二，这两部分各自还需要T(n/2)的时间，依次划分下去：T(n) = 2*T(n/2)+n    T(n) = 2*(2*(T(n/4)+n/2)+n = 4*T(n/4)+2n 等等，且T(1) = 0，所以T(n) = n*T(1) + n*logn = O(nlogn)
最坏情况：当待排序列为有序序列(正序或倒序)，每次划分后得到的情况是一侧有1个元素，另一侧是其余元素，则最终要进行n-1轮循环，且第i次循环要进行n-i次比较，总比较次数为n-1 + n-2 + ... + 1 = n(n-1)/2，即时间复杂度为O(n2)

3.2归并排序
时间复杂度：归并排序主要分为拆分和对有序数组进行排序，拆分操作的时间复杂度为logn，排序的复杂度为n，所以归并排序的时间复杂度为O(nlogn)
归并排序的空间复杂度就是那个临时数组和递归时压如栈的数据占用的空间：n + logn，所以空间复杂度为O(n)
基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。归并排序中第二步，对两个有序数组排序法则非常简单，同时对两个数组的第一个位置比较大小，将小的放入一个空数组，然后被放入空数组的那个位置的指针往后移一个，然后继续和另一个数组的上一个位置进行比较，以此类推。直到最后任何一个数组先出栈完，就将另外一个数组里的所有元素追加到新数组后面。
归并排序和快速排序有那么点异曲同工之妙，快速排序：是先把数组粗略的排序成两个子数组，然后递归再粗略分两个子数组，直到子数组里面只有一个元素，那么就自然排好序了，可以总结为先排序再递归；归并排序：先什么都不管，把数组分为两个子数组，一直递归把数组划分为两个子数组，直到数组里只有一个元素，这时候才开始排序，让两个数组间排好序，依次按照递归的返回来把两个数组进行排好序，到最后就可以把整个数组排好序。

3.3堆排序
堆排序是一种树形选择排序，是对直接选择排序的有效改进。
堆的定义下：具有n个元素的序列 （h1,h2,…,hn),当且仅当满足（hi>=h2i,hi>=2i+1）或（hi<=h2i,hi<=2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。 （可以延伸到前序遍历、中序遍历、后序遍历）
思想：初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。
难点有(1)如何把一个序列生成大根堆(2)输出堆顶元素后，如何使剩下的元素生成一个大根堆

堆排序的时间复杂度主要由两部分组成：初始化建堆和每次弹出堆顶元素后重新建堆的过程
初始化建堆过程的时间复杂度O(n)：假设堆的高度为k，则从倒数第二层右边的节点开始，这一层的节点都要进行子节点比较然后选择是否交换，倒数第三层类似，一直到第一层(即层数从k-1到1)；那么总的时间为(2^(i-1))*(k-i)，其中i表示第i层(范围是k-1到1)，2^(i-1)表示该层上有多少元素，(k-i)表示子树上要比较的次数，即S = 2^(k-2)*1 + 2^(k-3)*2 + 2^(k-4)*3 + ... + 2^1*(k-2) + 2^0*(k-1)，使用错位相减法(用常数2来辅助转换，两边都乘以2再减去原等式)得到S = 2^(K-1) + 2^(K-2) + 2^(K-3) + ... + 2 - (K-1)，忽略最后一项常数项就是等比数列，即S=2^k-2-(k-1)=2^k-k-1，又因为k为完全二叉树的深度，所以有 2^k <= n < 2^k-1，可以认为k = logn，综上所述S = n - logn -1，所以时间复杂度为O(n)
弹出堆顶元素后重建堆过程的时间复杂度O(nlogn)：循环n-1次，每次都从跟节点往下循环查找所以每一次时间都是logn，总时间为(n-1)*logn = nlogn - logn
故堆排序的时间复杂度为O(n) + O(nlogn) = O(nlogn)
堆排序是接地排序，所以空间复杂度为常数O(1)

4.选择排序
思想：每趟从待排序的记录序列中选择关键字最小的记录放置到已排序表的最前位置，直到全部排完。
关键问题：在剩余的待排序记录序列中找到最小关键码记录。
方法：
直接选择排序
选择排序第一轮内循环比较n-1次，然后是n-2次、n-3次........最后一轮内循环比较1次，共(n-1)+(n-2)+....+3+2+1=(n-1+1)n/2=n^2/2，其时间复杂度为O(n2)
空间复杂度就是在交换元素时那个临时变量所占的内存空间，空间复杂度为O(1)


5.插入排序
思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置，直到全部插入排序完为止。
关键问题：在前面已经排好序的序列中找到合适的插入位置。
方法：
    直接插入排序
	基本思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。（是一种最简单的排序方法，其基本操作是将一条记录插入到已排好的有序表中，从而得到一个新的、记录数量增1的有序表。）
    插入排序的最好情况是数组已经有序，此时只需要进行n-1次比较，时间复杂度为O(n)
    最坏情况是数组逆序排序，此时需要进行n(n-1)/2次比较以及n-1次赋值操作（插入）
    平均来说插入排序算法的复杂度为O(n2)
    空间复杂度上，直接插入法是就地排序，空间复杂度为(O(1))

    二分插入排序
	基本思想：二分法插入排序的思想和直接插入一样，只是找合适的插入位置的方式不同，这里是按二分法找到合适的位置，可以减少比较的次数。
    最坏情况：每次都在有序序列的起始位置插入，则整个有序序列的元素需要后移，时间复杂度为O(n2)
    最好情况：待排序数组本身就是正序的，每个元素所在位置即为它的插入位置，此时时间复杂度仅为比较时的时间复杂度，为O(log2n)
    平均情况：O(n2)
    空间复杂度上，二分插入也是就地排序，空间复杂度为(O(1))。

ref:https://www.cnblogs.com/zwtgyh/p/10631760.html